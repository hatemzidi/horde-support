#!/bin/sh
#
# Copyright (c) 2007 Andy Parkins
# Copyright (c) 2012 The Horde Project
#
# This hook will automatically split the base horde repository into
# separate modules and push those into separate repositories on
# github. "git subtree" is the command that the script uses to execute
# the module split.
#
# The hook is expected to be installed into a "bare" git repository
# (configured by running "git config --bool core.bare true"). This is
# necessary so that this repository can be used as a mirror with "git
# push --mirror". "git subtree" however only works on a checkout. So
# this hook expects an external git checkout in a directory "checkout"
# right beside the directory containing only the ".git" dir.
#
# Examle:
#.
#|-- horde-split
#    |-- git
#    |   `-- .git
#    |-- checkout
#        |-- ansel
#        |-- horde
#        |-- imp
#        ...
#
autosplit()
{
	# --- Arguments
	oldrev=$(git rev-parse $1)
	newrev=$(git rev-parse $2)
	refname="$3"

	# --- Interpret
	# 0000->1234 (create)
	# 1234->2345 (update)
	# 2345->0000 (delete)
	if expr "$oldrev" : '0*$' >/dev/null
	then
		change_type="create"
	else
		if expr "$newrev" : '0*$' >/dev/null
		then
			change_type="delete"
		else
			change_type="update"
		fi
	fi

	# --- Get the revision types
	newrev_type=$(git cat-file -t $newrev 2> /dev/null)
	oldrev_type=$(git cat-file -t "$oldrev" 2> /dev/null)
	case "$change_type" in
	create|update)
		rev="$newrev"
		rev_type="$newrev_type"
		;;
	delete)
		rev="$oldrev"
		rev_type="$oldrev_type"
		;;
	esac

	# The revision type tells us what type the commit is, combined with
	# the location of the ref we can decide between
	#  - working branch
	#  - tracking branch
	#  - unannoted tag
	#  - annotated tag
	case "$refname","$rev_type" in
		refs/heads/*,commit)
			# branch
			refname_type="branch"
			short_refname=${refname##refs/heads/}
			echo >&2 "*** Handling combination ($rev_type, $refname)."
			;;
		refs/tags/*,commit)
			echo >&2 "*** Ignoring combination ($rev_type, $refname)."
			exit 0
			;;
		refs/tags/*,tag)
			echo >&2 "*** Ignoring combination ($rev_type, $refname)."
			exit 0
			;;
		refs/remotes/*,commit)
			echo >&2 "*** Ignoring combination ($rev_type, $refname)."
			exit 0
			;;
		*)
			# Anything else (is there anything else?)
			echo >&2 "*** Unknown type of update to $refname ($rev_type)"
			exit 1
			;;
	esac

	subtrees="framework/Translation"

	for subtree in $subtrees;
	do
	    case "$subtree" in
		framework/*)
		    module=Horde_${subtree##framework/}
		    ;;
		*)
		    module=$subtree
		    ;;
	    esac
            git_tree=$(git rev-parse --git-dir 2>/dev/null)
            work_tree=$git_tree/../../checkout
            GIT_WORK_TREE=$work_tree git checkout $short_refname
            cd $work_tree
            GIT_WORK_TREE=$work_tree  GIT_DIR=$git_tree/.git git subtree split --prefix=$subtree --annotate="(horde) " --branch subtrees/$module/master --rejoin
            cd $git_tree
            git push git://github.com:horde/$module.git subtrees/$module/$short_refname:$short_refname
	done
}

while read oldrev newrev refname
do
    # Currently deactivated until this approach has been discussed and shown to be working
    #autosplit $oldrev $newrev $refname
done
